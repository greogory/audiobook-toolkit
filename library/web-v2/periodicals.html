<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reading Room - Periodicals</title>
    <link rel="stylesheet" href="css/periodicals.css">
</head>
<body>
    <!-- Header -->
    <header class="reading-room-header">
        <div class="header-content">
            <div class="title-section">
                <a href="index.html" class="back-link" title="Return to Library">
                    <span class="back-arrow">‚Üê</span>
                </a>
                <h1 class="room-title">Reading Room</h1>
                <p class="room-subtitle">Periodicals, Podcasts & More</p>
            </div>

            <!-- Sync Status & Refresh Button -->
            <div class="sync-controls">
                <div class="sync-status" id="sync-status" title="Last sync status">
                    <span class="sync-icon">‚ü≥</span>
                    <span class="sync-text">Idle</span>
                </div>
                <button class="refresh-btn" id="refresh-btn"
                        title="Refresh periodicals index from Audible">
                    <span class="refresh-icon">‚Üª</span>
                    <span class="refresh-text">Sync Now</span>
                </button>
            </div>
        </div>

        <!-- Category Tabs -->
        <nav class="category-tabs">
            <button class="category-tab active" data-category="all" title="Show all periodicals">All</button>
            <button class="category-tab" data-category="podcast" title="Podcasts and audio series">Podcasts</button>
            <button class="category-tab" data-category="news" title="Newspapers and news digests">News</button>
            <button class="category-tab" data-category="meditation" title="Meditation and sleep content">Meditation</button>
            <button class="category-tab" data-category="other" title="Other periodical content">Other</button>
        </nav>
    </header>

    <!-- Main Content -->
    <main class="reading-room-main">
        <!-- Left Panel: Periodicals List -->
        <aside class="parent-list-panel">
            <div class="panel-header">
                <h2>Publications</h2>
                <span class="parent-count" id="parent-count">-</span>
            </div>

            <div class="parent-list" id="parent-list">
                <div class="loading-indicator">Loading...</div>
            </div>
        </aside>

        <!-- Right Panel: Item Details -->
        <section class="episode-list-panel">
            <div class="panel-header">
                <div class="episode-header-left">
                    <h2 id="episode-panel-title">Select a publication</h2>
                    <span class="episode-count" id="episode-count"></span>
                </div>
            </div>

            <div class="episode-list" id="episode-list">
                <div class="empty-state">
                    <span class="empty-icon">üì∞</span>
                    <p>Select a publication from the left to view details</p>
                </div>
            </div>
        </section>
    </main>

    <!-- Download Queue Toast -->
    <div class="queue-toast" id="queue-toast" style="display: none;">
        <div class="queue-toast-content">
            <span class="queue-icon">üì•</span>
            <span class="queue-text" id="queue-text">Item queued for download</span>
            <button class="queue-close" id="queue-close" title="Dismiss">√ó</button>
        </div>
    </div>

    <script>
        // ========================================
        // Periodicals Reading Room - New Flat Schema
        // Each periodical is a standalone item (no episodes)
        // ========================================

        const API_BASE = '/api/v1/periodicals';
        let currentCategory = 'all';
        let currentAsin = null;
        let sseConnection = null;

        // ========================================
        // Safe DOM Creation Utilities
        // ========================================
        function createElement(tag, attrs = {}, children = []) {
            const el = document.createElement(tag);
            for (const [key, value] of Object.entries(attrs)) {
                if (key === 'className') {
                    el.className = value;
                } else if (key === 'textContent') {
                    el.textContent = value;
                } else if (key.startsWith('data')) {
                    el.dataset[key.slice(4).toLowerCase()] = value;
                } else if (key.startsWith('on') && typeof value === 'function') {
                    el.addEventListener(key.slice(2).toLowerCase(), value);
                } else {
                    el.setAttribute(key, value);
                }
            }
            children.forEach(child => {
                if (typeof child === 'string') {
                    el.appendChild(document.createTextNode(child));
                } else if (child) {
                    el.appendChild(child);
                }
            });
            return el;
        }

        function clearElement(el) {
            while (el.firstChild) {
                el.removeChild(el.firstChild);
            }
        }

        // ========================================
        // SSE Connection for Sync Status
        // ========================================
        function connectSSE() {
            if (sseConnection) sseConnection.close();

            sseConnection = new EventSource(API_BASE + '/sync/status');

            sseConnection.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    updateSyncStatus(data);
                } catch (e) {
                    console.error('SSE parse error:', e);
                }
            };

            sseConnection.onerror = function() {
                updateSyncStatus({ status: 'disconnected' });
                setTimeout(connectSSE, 5000);
            };
        }

        function updateSyncStatus(data) {
            const statusEl = document.getElementById('sync-status');
            const textEl = statusEl.querySelector('.sync-text');
            const iconEl = statusEl.querySelector('.sync-icon');
            const refreshBtn = document.getElementById('refresh-btn');

            statusEl.classList.remove('syncing', 'error', 'success');

            switch (data.status) {
                case 'running':
                    statusEl.classList.add('syncing');
                    iconEl.textContent = '‚ü≥';
                    textEl.textContent = 'Syncing ' + (data.processed || 0) + '/' + (data.total || '?') + '...';
                    refreshBtn.disabled = true;
                    break;
                case 'completed':
                    statusEl.classList.add('success');
                    iconEl.textContent = '‚úì';
                    textEl.textContent = (data.new || 0) + ' new items';
                    refreshBtn.disabled = false;
                    loadPeriodicalsList();
                    break;
                case 'failed':
                    statusEl.classList.add('error');
                    iconEl.textContent = '‚úó';
                    textEl.textContent = 'Sync failed';
                    refreshBtn.disabled = false;
                    break;
                default:
                    iconEl.textContent = '‚ü≥';
                    textEl.textContent = 'Idle';
                    refreshBtn.disabled = false;
            }
        }

        // ========================================
        // Sync Trigger (On-Demand Refresh)
        // ========================================
        async function triggerSync() {
            const refreshBtn = document.getElementById('refresh-btn');
            refreshBtn.disabled = true;

            try {
                const response = await fetch(API_BASE + '/sync/trigger', { method: 'POST' });
                if (response.ok) {
                    updateSyncStatus({ status: 'running', processed: 0, total: '?' });
                }
            } catch (error) {
                console.error('Sync trigger failed:', error);
                refreshBtn.disabled = false;
            }
        }

        // ========================================
        // Periodicals List Loading & Rendering
        // ========================================
        async function loadPeriodicalsList() {
            const container = document.getElementById('parent-list');
            clearElement(container);
            container.appendChild(createElement('div', { className: 'loading-indicator', textContent: 'Loading...' }));

            try {
                let url = API_BASE;
                if (currentCategory !== 'all') {
                    url += '?category=' + currentCategory;
                }
                const response = await fetch(url);
                const data = await response.json();
                renderPeriodicalsList(data.periodicals || []);
            } catch (error) {
                clearElement(container);
                container.appendChild(createEmptyState('‚ö†Ô∏è', 'Failed to load periodicals'));
            }
        }

        function renderPeriodicalsList(periodicals) {
            const container = document.getElementById('parent-list');
            const countEl = document.getElementById('parent-count');

            countEl.textContent = String(periodicals.length);
            clearElement(container);

            if (periodicals.length === 0) {
                container.appendChild(createEmptyState('üì≠', 'No periodicals in this category'));
                return;
            }

            periodicals.forEach(function(p) {
                container.appendChild(createPeriodicalCard(p));
            });
        }

        function createPeriodicalCard(p) {
            const coverContent = p.cover_url
                ? createElement('img', { src: p.cover_url, alt: '', loading: 'lazy' })
                : createElement('span', { className: 'no-cover', textContent: 'üìª' });

            // Status badges
            const badges = [];
            if (p.content_type) {
                badges.push(createElement('span', {
                    className: 'type-badge',
                    textContent: p.content_type
                }));
            }
            if (p.is_downloaded) {
                badges.push(createElement('span', {
                    className: 'downloaded-badge',
                    textContent: '‚úì Downloaded'
                }));
            }
            if (p.download_requested && !p.is_downloaded) {
                badges.push(createElement('span', {
                    className: 'queued-badge',
                    textContent: '‚è≥ Queued'
                }));
            }

            const card = createElement('button', {
                className: 'parent-card' + (p.asin === currentAsin ? ' active' : ''),
                dataAsin: p.asin,
                title: p.title + ' - ' + (p.content_type || 'Periodical'),
                onClick: function() { selectPeriodical(p.asin); }
            }, [
                createElement('div', { className: 'parent-cover' }, [coverContent]),
                createElement('div', { className: 'parent-info' }, [
                    createElement('span', { className: 'parent-title', textContent: p.title }),
                    createElement('span', { className: 'parent-author', textContent: p.author || '' }),
                    createElement('span', { className: 'parent-meta' }, badges)
                ])
            ]);

            return card;
        }

        function createEmptyState(icon, message) {
            return createElement('div', { className: 'empty-state' }, [
                createElement('span', { className: 'empty-icon', textContent: icon }),
                createElement('p', { textContent: message })
            ]);
        }

        // ========================================
        // Periodical Details View
        // ========================================
        async function selectPeriodical(asin) {
            currentAsin = asin;

            // Update active state in list
            document.querySelectorAll('.parent-card').forEach(function(card) {
                card.classList.toggle('active', card.dataset.asin === asin);
            });

            const container = document.getElementById('episode-list');
            clearElement(container);
            container.appendChild(createElement('div', { className: 'loading-indicator', textContent: 'Loading details...' }));

            try {
                const response = await fetch(API_BASE + '/' + asin);
                const data = await response.json();
                renderPeriodicalDetails(data);
            } catch (error) {
                clearElement(container);
                container.appendChild(createEmptyState('‚ö†Ô∏è', 'Failed to load details'));
            }
        }

        function renderPeriodicalDetails(item) {
            const container = document.getElementById('episode-list');
            const titleEl = document.getElementById('episode-panel-title');
            const countEl = document.getElementById('episode-count');

            titleEl.textContent = item.title;
            countEl.textContent = item.content_type || 'Periodical';

            clearElement(container);

            // Build details card
            const detailsCard = createElement('div', { className: 'details-card' }, [
                // Cover and basic info
                createElement('div', { className: 'details-header' }, [
                    item.cover_url
                        ? createElement('img', {
                            src: item.cover_url,
                            alt: item.title,
                            className: 'details-cover'
                        })
                        : createElement('div', { className: 'details-cover no-cover', textContent: 'üìª' }),
                    createElement('div', { className: 'details-info' }, [
                        createElement('h3', { className: 'details-title', textContent: item.title }),
                        createElement('p', { className: 'details-author', textContent: 'By ' + (item.author || 'Unknown') }),
                        item.narrator
                            ? createElement('p', { className: 'details-narrator', textContent: 'Narrated by ' + item.narrator })
                            : null,
                        createElement('p', { className: 'details-type', textContent: item.content_type + ' ‚Ä¢ ' + item.category }),
                        item.runtime_minutes
                            ? createElement('p', { className: 'details-runtime', textContent: formatDuration(item.runtime_minutes) })
                            : null,
                        item.release_date
                            ? createElement('p', { className: 'details-date', textContent: 'Released: ' + formatDate(item.release_date) })
                            : null
                    ])
                ]),

                // Description
                item.description
                    ? createElement('div', { className: 'details-description' }, [
                        createElement('h4', { textContent: 'Description' }),
                        createElement('p', { textContent: item.description })
                    ])
                    : null,

                // Status & Actions
                createElement('div', { className: 'details-actions' }, [
                    item.is_downloaded
                        ? createElement('div', { className: 'status-downloaded' }, [
                            createElement('span', { className: 'status-icon', textContent: '‚úì' }),
                            createElement('span', { textContent: 'Downloaded to Library' })
                        ])
                        : item.download_requested
                            ? createElement('div', { className: 'status-queued' }, [
                                createElement('span', { className: 'status-icon', textContent: '‚è≥' }),
                                createElement('span', { textContent: 'Queued for Download' })
                            ])
                            : createElement('button', {
                                className: 'download-btn',
                                title: 'Queue this item for download',
                                onClick: function() { queueDownload(item.asin); }
                            }, [
                                createElement('span', { className: 'download-icon', textContent: '‚Üì' }),
                                createElement('span', { textContent: 'Queue for Download' })
                            ])
                ]),

                // Metadata
                createElement('div', { className: 'details-meta' }, [
                    createElement('p', { textContent: 'ASIN: ' + item.asin }),
                    item.last_synced
                        ? createElement('p', { textContent: 'Last synced: ' + formatDate(item.last_synced) })
                        : null
                ])
            ]);

            container.appendChild(detailsCard);
        }

        // ========================================
        // Download Queue
        // ========================================
        async function queueDownload(asin) {
            try {
                const response = await fetch(API_BASE + '/download', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ asins: [asin] })
                });

                const data = await response.json();
                if (data.queued > 0) {
                    showQueueToast('Item queued for download', false);
                    // Refresh the details view
                    selectPeriodical(asin);
                    // Also refresh the list to update badges
                    loadPeriodicalsList();
                } else if (data.already_downloaded > 0) {
                    showQueueToast('Already downloaded', false);
                } else if (data.already_queued > 0) {
                    showQueueToast('Already in queue', false);
                }
            } catch (error) {
                showQueueToast('Failed to queue download', true);
            }
        }

        function showQueueToast(message, isError) {
            const toast = document.getElementById('queue-toast');
            const text = document.getElementById('queue-text');
            text.textContent = message;
            toast.classList.toggle('error', isError);
            toast.style.display = 'flex';

            setTimeout(function() {
                toast.style.display = 'none';
            }, 4000);
        }

        // ========================================
        // Category Tabs
        // ========================================
        document.querySelectorAll('.category-tab').forEach(function(tab) {
            tab.addEventListener('click', function() {
                document.querySelectorAll('.category-tab').forEach(function(t) {
                    t.classList.remove('active');
                });
                tab.classList.add('active');
                currentCategory = tab.dataset.category;
                currentAsin = null;

                // Reset details panel
                document.getElementById('episode-panel-title').textContent = 'Select a publication';
                document.getElementById('episode-count').textContent = '';
                const detailsContainer = document.getElementById('episode-list');
                clearElement(detailsContainer);
                detailsContainer.appendChild(createEmptyState('üì∞', 'Select a publication from the left to view details'));

                loadPeriodicalsList();
            });
        });

        // ========================================
        // Event Listeners
        // ========================================
        document.getElementById('refresh-btn').addEventListener('click', triggerSync);
        document.getElementById('queue-close').addEventListener('click', function() {
            document.getElementById('queue-toast').style.display = 'none';
        });

        // ========================================
        // Utilities
        // ========================================
        function formatDate(dateStr) {
            if (!dateStr) return '';
            try {
                const date = new Date(dateStr);
                return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
            } catch (e) {
                return dateStr;
            }
        }

        function formatDuration(minutes) {
            if (!minutes) return '';
            if (minutes < 60) return minutes + ' minutes';
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            if (mins === 0) return hours + ' hours';
            return hours + 'h ' + mins + 'm';
        }

        // ========================================
        // Initialize
        // ========================================
        document.addEventListener('DOMContentLoaded', function() {
            connectSSE();
            loadPeriodicalsList();
        });
    </script>
</body>
</html>
