#!/bin/bash
# =============================================================================
# Parallel Audiobook AAXC to Opus Converter
# =============================================================================
# Runs continuously, watching for new audiobooks to convert
# Waits if downloads are in progress
# Uses GNU parallel for multi-core conversion
# =============================================================================

# Load configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [[ -f "${SCRIPT_DIR}/../lib/audiobooks-config.sh" ]]; then
    source "${SCRIPT_DIR}/../lib/audiobooks-config.sh"
elif [[ -f "/opt/audiobooks/lib/audiobooks-config.sh" ]]; then
    source "/opt/audiobooks/lib/audiobooks-config.sh"
elif [[ -f "/usr/local/lib/audiobooks/audiobooks-config.sh" ]]; then
    source "/usr/local/lib/audiobooks/audiobooks-config.sh"
else
    echo "ERROR: Cannot find audiobooks-config.sh" >&2
    exit 1
fi

# Configuration (use config values or defaults)
SOURCES_DIR="${AUDIOBOOKS_SOURCES}"
LIBRARY_DIR="${AUDIOBOOKS_LIBRARY}"
OUTPUT_DIR="$AUDIOBOOKS_STAGING"
CONVERTER_PATH="$AUDIOBOOKS_CONVERTER"
LOG_DIR="$AUDIOBOOKS_LOGS"
OPUS_LEVEL="$AUDIOBOOKS_OPUS_LEVEL"
DOWNLOADER_LOCK="$AUDIOBOOKS_DOWNLOADER_LOCK"
PARALLEL_JOBS="$AUDIOBOOKS_PARALLEL_JOBS"
SLEEP_INTERVAL="$AUDIOBOOKS_SCAN_INTERVAL"
TMPFS_MAX_USAGE="$AUDIOBOOKS_TMPFS_THRESHOLD"

mkdir -p "$OUTPUT_DIR" "$LOG_DIR"

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

# Check tmpfs usage and wait if too high
check_tmpfs_space() {
    local USAGE=$(df /tmp | tail -1 | awk '{print int($5)}')

    if [ "$USAGE" -ge "$TMPFS_MAX_USAGE" ]; then
        log "tmpfs usage at ${USAGE}% (threshold: ${TMPFS_MAX_USAGE}%) - waiting for mover to free space..."
        echo -e "${YELLOW}⏸ PAUSED${NC}: tmpfs at ${USAGE}% - waiting for space..."

        # Wait until usage drops below threshold
        while [ "$USAGE" -ge "$TMPFS_MAX_USAGE" ]; do
            sleep 30
            USAGE=$(df /tmp | tail -1 | awk '{print int($5)}')
        done

        log "tmpfs usage now at ${USAGE}% - resuming conversions"
        echo -e "${GREEN}▶ RESUMED${NC}: tmpfs at ${USAGE}%"
        return 0
    fi

    return 0
}

echo "========================================="
echo -e "${CYAN}PARALLEL OPUS CONVERTER (CONTINUOUS)${NC}"
echo "========================================="
echo "Parallel jobs: $PARALLEL_JOBS"
echo "Source: $SOURCES_DIR"
echo "Output: $OUTPUT_DIR"
echo "Library: $LIBRARY_DIR"
echo "Scan interval: ${SLEEP_INTERVAL}s when idle"
echo ""

# Function to convert a single file
# Note: Queue file is authoritative - it already does normalized title matching
# We only need to check for downloads in progress here
convert_file() {
    local AAXC_FILE="$1"
    local BASENAME=$(basename "$AAXC_FILE" .aaxc)
    local LOG_FILE="$LOG_DIR/conversion_${BASENAME}.log"

    # Check if source file still exists (queue might be stale)
    if [[ ! -f "$AAXC_FILE" ]]; then
        echo -e "${YELLOW}⊘ SKIP${NC}: $BASENAME (source file missing)"
        return 0
    fi

    # Check if file is still being downloaded (modified in last 2 minutes)
    if find "$AAXC_FILE" -mmin -2 2>/dev/null | grep -q .; then
        echo -e "${YELLOW}⊘ SKIP${NC}: $BASENAME (still downloading - modified recently)"
        return 0
    fi

    # Also check file size stability (file should not be growing)
    local SIZE1=$(stat -c%s "$AAXC_FILE" 2>/dev/null)
    sleep 2
    local SIZE2=$(stat -c%s "$AAXC_FILE" 2>/dev/null)
    if [ "$SIZE1" != "$SIZE2" ]; then
        echo -e "${YELLOW}⊘ SKIP${NC}: $BASENAME (file size changing - download in progress)"
        return 0
    fi

    echo -e "${CYAN}▶ START${NC}: $BASENAME"

    # Record start time for finding newly created output files
    local START_TIME=$(date +%s)

    # Get converter directory
    local CONVERTER_DIR=$(dirname "$CONVERTER_PATH")

    # Convert using audible-cli voucher data (required for AAXC files)
    # Use -D to skip genre level (avoid nested Audiobook/Author/Title structure)
    # ionice -c2 -n0: best-effort class, highest priority (0) for faster I/O
    if cd "$CONVERTER_DIR" && \
       ionice -c2 -n0 bash "$(basename "$CONVERTER_PATH")" --opus --single --level "$OPUS_LEVEL" \
           --use-audible-cli-data \
           --target_dir "$OUTPUT_DIR" \
           -D '$artist/$title' \
           --loglevel 0 \
           "$AAXC_FILE" > "$LOG_FILE" 2>&1; then

        # Find newly created opus file (AAXtoMP3 renames to actual book title)
        # Look for .opus files created after conversion started, excluding cover files
        local OUTPUT_FILE=$(find "$OUTPUT_DIR" -name "*.opus" -type f ! -name "*.cover.opus" -newermt "@$START_TIME" 2>/dev/null | head -1)
        if [ -n "$OUTPUT_FILE" ]; then
            local FILE_SIZE=$(stat -c%s "$OUTPUT_FILE" 2>/dev/null || echo "0")

            # Check if file is larger than 100KB (minimum valid audiobook size)
            if [ "$FILE_SIZE" -lt 102400 ]; then
                echo -e "${RED}✗ CORRUPT${NC}: $BASENAME (output only ${FILE_SIZE} bytes - removing)"
                rm -f "$OUTPUT_FILE"

                # Also check if source AAXC is corrupted
                local SOURCE_SIZE=$(stat -c%s "$AAXC_FILE" 2>/dev/null || echo "0")
                if [ "$SOURCE_SIZE" -lt 102400 ]; then
                    echo -e "${RED}  Source file also corrupted (${SOURCE_SIZE} bytes)${NC}"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] CORRUPTED SOURCE: $AAXC_FILE (${SOURCE_SIZE} bytes)" >> "$LOG_DIR/corrupted_sources.log"
                fi
                return 1
            fi

            local SIZE=$(du -h "$OUTPUT_FILE" 2>/dev/null | cut -f1)
            echo -e "${GREEN}✓ DONE${NC}: $BASENAME ($SIZE)"
        else
            echo -e "${RED}✗ FAIL${NC}: $BASENAME (output file not found)"
            return 1
        fi
    else
        echo -e "${RED}✗ FAIL${NC}: $BASENAME (see $LOG_FILE)"
        return 1
    fi
}

export -f convert_file check_tmpfs_space
export OUTPUT_DIR CONVERTER_PATH LOG_DIR OPUS_LEVEL LIBRARY_DIR
export RED GREEN YELLOW CYAN NC DOWNLOADER_LOCK TMPFS_MAX_USAGE

# Continuous loop - keep scanning for new files
while true; do
    # Check tmpfs space before proceeding
    check_tmpfs_space

    # Check if downloader is active
    if [ -f "$DOWNLOADER_LOCK" ] && flock -n "$DOWNLOADER_LOCK" true 2>/dev/null; then
        # Lock exists but is not held - stale lock, safe to proceed
        :
    elif [ -f "$DOWNLOADER_LOCK" ]; then
        # Lock is held - downloader is active
        log "Download in progress - waiting for completion..."
        sleep 30
        continue
    fi

    # Use queue file instead of finding all sources
    # Queue contains only files that need conversion (sources - already converted)
    # This is authoritative: queue builder does normalized title matching correctly
    QUEUE_FILE="${AUDIOBOOKS_DATA:-/raid0/Audiobooks}/.index/queue.txt"
    QUEUE_BUILDER="${AUDIOBOOKS_HOME:-/opt/audiobooks}/scripts/build-conversion-queue"

    # Rebuild queue if missing, empty, or stale (older than 10 minutes)
    REBUILD_QUEUE=false
    if [[ ! -f "$QUEUE_FILE" ]]; then
        log "Queue file missing - rebuilding..."
        REBUILD_QUEUE=true
    elif [[ ! -s "$QUEUE_FILE" ]]; then
        # Queue exists but empty - check if it's stale
        if [[ -n "$(find "$QUEUE_FILE" -mmin +10 2>/dev/null)" ]]; then
            log "Queue empty and stale - rebuilding..."
            REBUILD_QUEUE=true
        fi
    fi

    if $REBUILD_QUEUE && [[ -x "$QUEUE_BUILDER" ]]; then
        "$QUEUE_BUILDER" --rebuild >/dev/null 2>&1
    fi

    # Read queue (files that need conversion)
    if [[ -f "$QUEUE_FILE" ]] && [[ -s "$QUEUE_FILE" ]]; then
        AAXC_FILES=$(cat "$QUEUE_FILE")
    else
        AAXC_FILES=""
    fi

    if [ -z "$AAXC_FILES" ]; then
        log "Queue empty - all files converted. Waiting ${SLEEP_INTERVAL}s..."
        sleep "$SLEEP_INTERVAL"
        continue
    fi

    # Count files to process
    TOTAL_AAXC=$(echo "$AAXC_FILES" | wc -l)
    log "Queue has $TOTAL_AAXC files needing conversion..."

    # Process files in parallel
    # Use --bar for progress only when running interactively (TTY available)
    if [[ -t 1 ]]; then
        echo "$AAXC_FILES" | parallel -j "$PARALLEL_JOBS" --bar convert_file {}
    else
        echo "$AAXC_FILES" | parallel -j "$PARALLEL_JOBS" convert_file {}
    fi

    echo ""
    echo "========================================="
    COMPLETED=$(find "$OUTPUT_DIR" -name "*.opus" -type f ! -name "*.cover.opus" 2>/dev/null | wc -l)
    FINAL=$(find "$LIBRARY_DIR" -name "*.opus" -type f ! -name "*.cover.opus" 2>/dev/null | wc -l)
    echo -e "${GREEN}In staging: $COMPLETED | In library: $FINAL${NC}"
    echo "========================================="

    # Rebuild queue after batch to remove newly converted files
    # Run in background to not delay next scan
    if [[ -x "$QUEUE_BUILDER" ]]; then
        "$QUEUE_BUILDER" --rebuild >/dev/null 2>&1 &
    fi

    log "Batch complete - waiting ${SLEEP_INTERVAL}s before next scan..."
    sleep "$SLEEP_INTERVAL"
done
